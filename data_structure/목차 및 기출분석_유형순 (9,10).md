**9. Sorting & Algorithm Efficiency**

[to recursive] (루프의 test = boundary case. 루프 후처리(예:i++) = 작은 문제 호출)

- 2001-5 insertionSort 알고리즘 recursive으로 바꾸기

  ```java
  insertionSort(A[], i, n) { // main에서 call할 때 2번째 index로 시작
      newItem = A[i];
      for (loc = i-1; loc >= 1 && newItem < A[loc]; loc--)
          A[loc+1] = A[loc]; // newItem보다 큰 애들은 한 칸씩 뒤로
      A[loc+1] = newItem; // newItem보다 같거나 작은 첫번째의 index가 리턴됨
      if (i + 1 <= n)
          insertionSort(arr, i+1, n);
  }
  ```

- 2003-7 2004-5 2005-4 selection sort를 recursive로 바꾸기

  ```java
  selectionSort(Arr[], n) {
      if (n > 1) {
          largest = indexOfLargest(Arr, n);
      	swap Arr[largest] & Arr[last];
          selectionSort(Arr[], n-1);
      }
  }
  indexOfLargest(Arr[], size) {
      largest = 0;
      for (i=1; i < size; ++i)
          if (Arr[i] > Arr[largest]) largest = i;
      return largest;
  ```

- 2016-4 radix sort 알고리즘 recursive으로 바꾸기

  ```java
  radixSort(A[], n, d) { // Sort n d-digit integers in array A[1..n]
      if (d >= 1) { // 1st digit = MSD
          radixSort(A, n, d-1);
          Do a stable sort on A[1..n] by d digit.
      }
  ```

[시간? 비교 몇 번? call 몇 번?]

- 2005-3 입력이 (1) 오름순 (2) 내림순으로 이미 소팅된 경우, selection, insertion, merge, quick 중 무엇이 오름순 Sorting에 가장 유리한가? 

  ```markdown
  (1) **insertionSort** - 아래 2002-3와 같은 이유로 선형시간이 든다. `Θ(n)`
  	- Θ(nlogn) 	: mergeSort, heapSort
  	- Θ(n^2) 	: selectionSort, bubbleSort, quickSort
  (2) **mergeSort** - worst case input이다. `Θ(nlogn)`
  	- Θ(nlogn)	: mergeSort, heapSort
  	- Θ(n^2)	: selectionSort, bubbleSort, insertionSort, quickSort
  ```

- 2012-1 insertion sort 알고리즘에서 (1) 한 칸씩 훑지 않고 A[k+1] 들어갈 자리 더 빠르게? (2) 이렇게 하면 점근적 수행 시간이 더 빨라질 것 같은데 그렇지 않은 이유는?

  ```markdown
  1.1. 기존 sequential search를 사용하면 평균적으로 `k/2`번의 비교가 필요하다. 즉 Θ(k) 소요. 이때 A[1...k]는 이미 정렬되어 있으므로 binary search를 이용하면 평균적으로 `log(k)`번의 비교로 자리를 찾을 수 있다. 즉 Θ(logk) 소요.
  1.2. 원소 A[k+1]가 들어갈 자리를 찾기 위한 시간은 절약할 수 있지만, 결국 A[k+1]가 들어갈 자리부터 오른쪽에 있는 원소들을 모두 한 칸씩 shift해야 하므로 점근적 시간이 절약되지 않는다. 각 A[k+1]를 위해 평균 `k/2`번의 shift가 필요하다.
  ```

- 2002-3 이미 sorting된 것을 insertion sort로 할 때 총 몇 번의 비교가 필요한가? (정확히)

  ```markdown
  # 0번의 비교가 필요하다.
  안쪽 루프는 한번도 수행 안되므로, 바깥 루프 한 번 순환할때마다 상수 시간 소요. 바깥 루프는 n-1번 순환하므로 **Θ(logn)**의 시간이 든다. 거의 정렬되어있을 때도 마찬가지.
  ```

- 2001-6 이미 sorting된 것을 mergesort할 때 총 몇 번의 비교가 필요한가? (n=2^k)

  ```java
  // 피피티 보기
  ```

- **2004-6 quicksort가 call되는 횟수**

  ```java

  ```

- 2007-6 mergeSort에서 **merge** 호출되는 횟수

  ```java
  (n-1)번 => 필기 // mergeSort는 2n-1번
  ```

- 2016-5 mergesort에서 counter가 가질 수 있는 최대값

  ```java
  k+1 => 필기
  ```

[제대로 소팅 증명]

- 2002-4 insertion sort가 제대로 sorting함을 수학적 귀납법으로 증명

  ```bash
  1 base case : n=1 맨 왼쪽 수 하나만으로 이루어져 있으므로 정렬이 되어 있다
  2 inductive hypothesis : n=k일 때 성립하면(정렬되어 있으면)
  3 inductive conclusion : 적절한 삽입에 의해서 n=k+1일 때도 성립한다(정렬이 된다)
  ```

- 2003S-3 (a)radix sort가 제대로 sorting함을 수학적 귀납법으로 증명 (b) radix sort내에서 각 자리에 대해 sorting하는 방법을 제시.

  ```bash
  (a) 1 base case : n=1 1번째 자리수에 대하여 stable sort하므로 정렬이 제대로 된다.
  2 inductive hypothesis: n<k일 때 k보다 작은 자리수에 대해 성립하면(정렬되어 있으면)
  3 inductive conclusion: k번째 자리수로 정렬을 하고 나면 n=k일 때도 성립한다. k번째 자리수가 같은 것은 귀납적 가정에 의해 k보다 작은 자리수로 정렬됐으므로 제대로 정렬된다.
  (b) 0부터 9까지 표시된 10개의 공간을 준비해놓고 각각의 수를 가진 입력은 해당 공간에 차례대로 넣어준다.
  ```

- 2011-1 (1) radix sort에서 맨뒷자리 대신 맨 앞자리부터 정렬해도 sorting이 제대로 되는가?

  ```bash
  안된다. 각각의 자리수는 동등한 수가 아닌 position value를 가지기 때문이다. position value가 가장 큰 most significant digit에 의한 정렬이 가장 나중에 반영되어야 제대로 정렬된다. 예컨대 22와 15 소팅 시 앞자리부터 정렬하면 15, 22 순이 되어버린다.
  ```

- 2004S-3 1/3, 2/3로 나누는 mergeSort는 제대로 sorting? n에 대한 running time은?

  ```bash
  O(nlogn) => 필기에 증명
  ```

- 2012-3 selection sort가 제대로 sorting하는가? (수학적귀납법으로 증명)

  ```bash
  1 base case : n=1 제대로 정렬됨
  2 inductive hypothesis : n=k 제대로 정렬된다고 가정했을 때,
  3 inductive conclusion : n=k+1
  	# selectionSort는 가장 먼저 k+1개의 item 중 가장 큰 값을 last index로 보냄
      # 이제 남은 k개를 정렬하면 된다. inductive hypothesis에 의해 k개는 제대로 정렬
  ```

- 2005-5 절반은 quickSort, 절반은 mSort 후, merge하는 식의 quicksort 제대로 sorting하는가?

  ```bash
  quicksort는 partition으로 기준보다 작은 수는 왼쪽에, 나머지는 오른쪽에 재배치하므로 왼쪽과 오른쪽을 독립적으로 정렬한다. 따라서 왼쪽과 오른쪽의 정렬방식이 다르더라도 각각 내부적으로 제대로 정렬만 되면 상관없다.
  ```

  2003S-6 절반은 quickSort, 절반은 mSort 후, merge하는 식의 mSort는 제대로 sorting?

  ```markdown
  first~last에서 mid의 오른쪽은 quicksort만으로 제대로 정렬된다. 왼쪽은 또다시 반으로 갈려 그 오른쪽은 quicksort만으로 제대로 정렬된다. 이와 같이 왼쪽 절반에 대한 quicksort가 반복되고 오른쪽 절반의 크기가 1이 될때까지 이는 반복된다. 결국 크기 n의 array를 mSort하면 n/2개, n/4, n/8, ..., 2, 1개에 대하여 각각 quickSort가 진행되고 이들이 작은 것부터 순차적으로 merge되는 것이다. quickSort는 제대로 sorting하고, merge는 제대로 두 정렬된 array를 합치기 때문에 mSort는 제대로 소팅한다.
  ```

[quicksort의 partition]

- 2003-5 quicksort를 위한 partition function에서 pivot보다 작거나 같은 원소를 왼쪽에, 큰 원소를 오른쪽에 둬도 제대로 되는가?

  ```java
  제대로 된다. 어차피 정렬 후 pivot element와 같은 원소는 그 양옆에 붙게 되기 때문.
  ```

- 2014-3 [이해도테스트] last를 pivot으로 삼는 Partition

  ```java
  int partition(A[], first, last) {
      pivot = A[last];
      // 나머지 동일
      A[last] <-> A[lastS1];
      return lastS1;
  ```

- 2011-3 partition을 사용하는 알고리즘 = 무엇을 하는가? 옳게 이루어지는가?

  ```markdown
  3.1. 정렬하는 알고리즘이다. quickSort와 같은 형태이나 partition을 3분할한다.
  3.2. 제대로 이루어진다. n=1, n=2일 때 잘 이루어지며 n<k일 때 성립함을 가정하면, n=k일 때 a보다작음<a<a보다크고b보다작음<b<b보다큼 로 정렬되는데, 이때 세 개의 그룹은 k보다 작은 크기이므로 제대로 소팅된다.
  ```

[stable sort]

- 2003-6 2004-4 mergesort가 stable sort가 되려면 어떻게 하는가?

  ```
  YES. merge에서 값을 비교한 후 tmp 배열로 옮겨 넣을 때, 왼쪽과 오른쪽의 원소가 같은 경우 왼쪽부터 꺼낸다는 일관성을 유지하면 안정성을 유지할 수 있다.
  ```

- 2004S-4 quicksort가 stable sort가 되려면 어떻게 하는가?

  ```
  1. Any sort can be converted to a stable sort if you're willing to add a second key. The second key should be something that indicates the original order, such as a sequence number. In your comparison function, if the first keys are equal, use the second key.
  2. partition에서 항상 중앙값을 pivot으로 잡는다
  ```

  2011-1 (4) partition을 사용하는 quicksort는 stable sorting인가? `NO`

- 2007-1.1 [점수주기] insertion sort는 stable sort인가? `YES`

- 2015-2 selectionSort에서 최대값이 두 개 이상 있을 때는 가장 뒤에 있는 것을 최대로 삼는다면 stable sorting이 되는가? `YES`

[개념 OX] - 인쇄 안해도 됨

- 2014-1 running time `X O O X`  2015-1 `X heap X O`

  ```markdown
  - quicksort의 asymptotic running time은 O(nlogn)이다 **X**
  worst case에는 Θ(n^2)이므로 O(nlogn)이 아니다.
  ```

**10. Tree**

- 2003-1 (2) 임의의 (3) Balanced binary search tree에서 검색 worst-case time

  ```markdown
  (2) O(n) (3) Θ(logn) (binary search tree's best-case)
  ```

- 2003-2 binary search tree에서 delete할 때 right subtree minimum element사용하는 것 외의 다른 방법은? right subtree에 전혀 변화가 없도록 하면서.

  ```markdown
  left tree의 maximum element를 사용한다.
  ```

- 2003-4 binary search tree의 각노드에 은행잔고 있을 때, 모든 노드의 잔고를 합하는 method를 recursion 사용하여 작성

  ```java
  public int balanceSum(BinaryNode t) {
      int sum = t.getItem();
      int += balanceSum(t.getLeft);
      int += balanceSum(t.getRight);
      return sum;
  }
  ```

- 2003S-1 Binary Search Tree class의 delete 좀 다르게 구현해보기

  ```java
  public BinaryNode delete(BinaryNode rootNode, Comparable searchKey) {
      if (rootNode == null) {exception handling} //not found
      else {
          if (searchkey.compareTo(rootNode.item) == 0)
              tNode = deleteNode(tNode);
          else if (searchkey.compareTo(rootNode.item) < 0)
              rootNode.leftChild=delete(rootNode.rightChild, searchKey);
  		else
              rootNode.rightChild=delete(rootNode.leftChild, searchKey);
      }
  }
  public BinaryNode deleteNode(BinaryNode tNode) {
      if (tNode.leftChild == null && tNode.rightChild == null)
          return null;
      else if (tNode.leftChild == null)
          return tNode.rightChild;
      else if (tNode.rightChild == null)
          return tNode.leftChild;
      else {
          BinaryNode min = tNode.rightChild;
          while (min.leftChild != null)
              min = min.leftChild;
          tNode.item = min.item;
          return deleteNode(min);
      }
  }
  ```

- 2003S-2 2007-2 binary tree의 height 구하는 recursive 알고리즘

  ```java
  int height(TreeNode t) {
      if (t == null)
          return 0;
      int leftHeight = height(t.leftChild);
      int rightHeight = height(t.RightChild);
      if (leftHeight < rightHeight)
          return (rightHeight + 1);
      else 
          return (leftHeight + 1);
  }
  ```

- 2003S-7 binary search tree의 root의 key 값이 바뀌면 성질이 깨진다 (a)어떻게 이를 판단? (b)어떻게 이를 조정?

  ```java
  keyChange(BinaryNode t, Comparable newKey) {
  	if (t.leftChild == newKey || t.rightChild == newKey) Error;
      else if (t.leftChild > newKey) { // 왼쪽 균형 깨질 때
          insert(t.leftChild, newKey);
          deleteNode(t);
      }
      else if (t.rightChild < newKey) { // 오른쪽 균형 깨질 때
          insert(t.rightChild, newKey);
          deleteNode(t);
      }
      else
      	t.item = newKey; 
  }
  // (a) newKey가 t의 leftChild보다 작거나 rightChild보다 클 때
  // (b) left or right subtree에 newKey를 insert하고, t는 deleteNode로 삭제.
  ```

- 2004S-1 Tom은 몇번째로 insertion? 가능한 모든 경우 `6, 5, 4, 3`

- 2004S-6 임의의 트리가 입력으로 주어질 때 폭이 가장 넓은 레벨과 해당 레벨의 폭을 출력하는 recursive 알고리즘.

  ```java
  int maxWidth(tNode root) {
      int width, i; int h = height(root); int maxWidth = 0;
      for (i = 1; i <= h; i++) {
          width = getWidth(node, i);
          if (width > maxWidth) maxWidth = width;
      }
      return maxWidth;
  }
  int getWidth(Node node, int level) {
      if (node == null) return 0;
      if (level == 1) return 1;
      else if (level > 1)
          return getWidth(node.left, level+1)
          + getWidth(node.right, level+1);
      return 0;
  }
  ```

- 2007-1 (2)n개의 키로부터 만들 수 있는 가능한 이진검색트리 경우의 수 (3) n개의 노드로 이루어진 완전이진트리를 root부터 1~n까지 번호를 붙일 때 i번 노드의 부모노드의 번호는?

- 2007-5 binary tree insert 알고리즘

- 2007-7 n개 원소 (parent < child) 만들 수 있는 가능한 이진트리의 총 수 Tn 재귀식

- 2012-2 binary search tree에 관한 정리가 empty bst에서 n개 삽입하는 데 소요되는 총 시간에 대해 어떤 것을 말해주고 있는가?​

- 2014-5 binary tree에서 children 2개 있을 경우 오른쪽 subtree 손대지 않고 대신 왼쪽 subtree에 손대는 알고리즘으로 delete 메소드 바꾸기

- 2015-3 n개의 서로 다른 key를 차례대로 받아 binary search tree를 만들었을 때, 만드는 과정에서 소요된 총 시간의 합은? Big-oh로 

- 2015-4 binary search tree에서 delete할 때, setLeft, setRight를 쓰지 않고 같은 의미를 가지는 코드 즉 후속함수의 return값을 기다리지 않도록.

  ```java
  cmp = searchKey.compareTo(tNode'skey);
  while (cmp != 0) {
    if (cmp < 0) tNode = tNode.getLeft();
    else tNode = tNode.getRight();
  }
  deleteNode(tNode);

- 2016-1 [점수주기] binary search tree에 insert 수행 시 (a)각 메소드 호출 횟수, (b)그 중 값 변하는 경우의 횟수

- 2016-6 binary search tree에서 x를 key로 가진 노드 삭제 알고리즘 - 문제와 보완책

**종합**

- 2001-2 5개 insert => 1개delete => 3개 남는 일이 일어날 수 있는 자료구조

  hash table, priority queue, queue, binary search tree, stack

- 2002-1 7개의 데이터 차례대로 넣은 후 자료구조에 저장된 모양

  stack, queue, binary search tree
